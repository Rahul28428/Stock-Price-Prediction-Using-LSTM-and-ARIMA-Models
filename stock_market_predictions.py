# -*- coding: utf-8 -*-
"""Stock Market Predictions

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kocEnv-t9P4QBaC0Rx8jIZ2ghoBAd5Py

# Stock Price Prediction Using LSTM

## Importing necessary Libraries
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import LSTM, Dense, Dropout
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.stattools import adfuller
from datetime import datetime
from sklearn.metrics import mean_squared_error
import yfinance as yf

# Defining the stock symbol and the date range
stock_symbol = 'AAPL'
end_date = datetime.now()
start_date = datetime(end_date.year-10, end_date.month, end_date.day)

# Fetching the data
data = yf.download(stock_symbol, start=start_date, end=end_date)

# Plotting the closing price
fig = go.Figure()
fig.add_trace(go.Scatter(x=data.index, y=data['Close'], mode='lines', name='Close Price'))
fig.update_layout(title=f'{stock_symbol} Closing Price', xaxis_title='Date', yaxis_title='Price')
fig.show()

data.head()

data.describe()

# Preparing the data for LSTM
data_lstm = data[['Close']]

# Scaling the data
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(data_lstm)

# Creating training and testing sets
train_size = int(len(scaled_data) * 0.8)
train_data, test_data = scaled_data[:train_size], scaled_data[train_size:]

# Creating the datasets for LSTM
def create_dataset(data, time_step=1):
    X, Y = [], []
    for i in range(len(data) - time_step - 1):
        X.append(data[i:(i + time_step), 0])
        Y.append(data[i + time_step, 0])
    return np.array(X), np.array(Y)

time_step = 60
X_train, Y_train = create_dataset(train_data, time_step)
X_test, Y_test = create_dataset(test_data, time_step)

# Reshaping for LSTM [samples, time steps, features]
X_train = X_train.reshape(X_train.shape[0], X_train.shape[1], 1)
X_test = X_test.reshape(X_test.shape[0], X_test.shape[1], 1)

"""## LSTM Model"""

# Building the LSTM model
model = Sequential()
model.add(LSTM(50, return_sequences=True, input_shape=(time_step, 1)))
model.add(LSTM(50, return_sequences=False))
model.add(Dense(25))
model.add(Dense(1))

# Compile the model
model.compile(optimizer='adam', loss='mean_squared_error')

# Train the model
model.fit(X_train, Y_train, batch_size=1, epochs=5)

model.summary()

# Save the LSTM model
model.save('lstm_stock_model.h5')

# Making predictions
train_predict = model.predict(X_train)
test_predict = model.predict(X_test)

# Inversing transform to get actual prices
train_predict = scaler.inverse_transform(train_predict)
test_predict = scaler.inverse_transform(test_predict)
actual_prices = scaler.inverse_transform(scaled_data)

"""## MSE"""

# Calculating MSE for LSTM
train_mse_lstm = mean_squared_error(scaler.inverse_transform(Y_train.reshape(-1, 1)), train_predict)
test_mse_lstm = mean_squared_error(scaler.inverse_transform(Y_test.reshape(-1, 1)), test_predict)

print(f"Mean Squared Error (MSE) for LSTM:")
print(f"- Training set: {train_mse_lstm:.2f}")
print(f"- Test set: {test_mse_lstm:.2f}")

# Plotting the predictions
train_predict_plot = np.empty_like(scaled_data)
train_predict_plot[:, :] = np.nan
train_predict_plot[time_step:len(train_predict) + time_step, :] = train_predict

test_predict_plot = np.empty_like(scaled_data)
test_predict_plot[:, :] = np.nan
test_predict_plot[len(train_predict) + (time_step * 2) + 1:len(scaled_data) - 1, :] = test_predict

fig = go.Figure()
fig.add_trace(go.Scatter(x=data.index, y=actual_prices[:, 0], mode='lines', name='Actual Prices'))
fig.add_trace(go.Scatter(x=data.index, y=train_predict_plot[:, 0], mode='lines', name='Train Predictions'))
fig.add_trace(go.Scatter(x=data.index, y=test_predict_plot[:, 0], mode='lines', name='Test Predictions'))
fig.update_layout(title=f'{stock_symbol} Price Prediction', xaxis_title='Date', yaxis_title='Price')
fig.show()

"""# Forecasting using ARIMA Model"""

pip install pmdarima

from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf
import pmdarima as pm
import pickle

data = data[['Close']].copy()

"""## Parameters for ARIMA model"""

result = adfuller(data.Close.dropna())

print(f"ADF Statistic: {result[0]}")
print(f"p-value: {result[1]}")

import matplotlib.pyplot as plt
from statsmodels.graphics.tsaplots import plot_acf

# Plotting the original time series with Matplotlib
plt.figure(figsize=(16, 6))
plt.subplot(1, 2, 1)
plt.plot(data.index, data['Close'], label='Original Series', color='blue')
plt.title('Original Time Series')
plt.xlabel('Date')
plt.ylabel('Close Price')
plt.legend()

# Plotting the Autocorrelation Function (ACF) with Matplotlib
plt.subplot(1, 2, 2)
plot_acf(data['Close'], ax=plt.gca(), title='Autocorrelation Function (ACF)', lags=40)

plt.tight_layout()
plt.show()

# Calculating first difference
diff1 = data['Close'].diff().dropna()

# Plotting the first difference and its ACF
fig, axs = plt.subplots(1, 2, figsize=(16, 6))

# Plotting first difference
axs[0].plot(diff1)
axs[0].set_title('First Difference of Close Price')
axs[0].set_xlabel('Date')
axs[0].set_ylabel('Difference')

# Plotting ACF of first difference
plot_acf(diff1, ax=axs[1], title='Autocorrelation Function (ACF) of First Difference', lags=40)

plt.tight_layout()
plt.show()

# Calculating second difference
diff2 = data['Close'].diff().diff().dropna()

# Plotting the second difference and its ACF
fig, axs = plt.subplots(1, 2, figsize=(16, 6))

# Plotting second difference
axs[0].plot(diff2)
axs[0].set_title('Second Difference of Close Price')
axs[0].set_xlabel('Date')
axs[0].set_ylabel('Difference')

# Plotting ACF of second difference
plot_acf(diff2, ax=axs[1], title='Autocorrelation Function (ACF) of Second Difference', lags=40)

plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
from statsmodels.graphics.tsaplots import plot_pacf

# Compute the first difference
diff = data['Close'].diff().dropna()

# Plotting the first difference with Matplotlib
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 4))
ax1.plot(diff)
ax1.set_title('Difference Once')

# Plotting the Partial Autocorrelation Function (PACF) with Matplotlib
plot_pacf(diff, ax=ax2, title='Partial Autocorrelation Function (PACF)')
plt.show()

"""p = 18"""

import matplotlib.pyplot as plt
from statsmodels.graphics.tsaplots import plot_acf

# Compute the first difference
diff = data['Close'].diff().dropna()

# Create subplots
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 4))

# Plotting the first difference
ax1.plot(diff)
ax1.set_title("Difference once")

# Adjust ylim for ACF plot
ax2.set_ylim(0, 1)

# Plotting the Autocorrelation Function (ACF)
plot_acf(diff, ax=ax2, title='Autocorrelation Function (ACF)')

plt.show()

"""q=9"""

from pmdarima.arima.utils import ndiffs
from statsmodels.tsa.stattools import adfuller

# Assuming 'data' is your dataframe and 'close' is the column you want to test
close_series = data['Close']

# ADF Test for determining initial differencing
adf_result = adfuller(close_series)
print(f"ADF Statistic: {adf_result[0]}")
print(f"p-value: {adf_result[1]}")

# Determine the number of differences needed
diffs = ndiffs(close_series, test='adf')
print(f"Number of Differences: {diffs}")

"""d = 1"""

close_series = data['Close']

"""## ARIMA Model"""

# Fitting the ARIMA model
model = ARIMA(close_series, order=(18, 1, 9))
model_fit = model.fit()

print(model_fit.summary())

# AIC and BIC scores
aic = model_fit.aic
bic = model_fit.bic

print(f"ARIMA Model Metrics - AIC: {aic:.2f}, BIC: {bic:.2f}")

# Save the model to a file using pickle
with open('arima_model.pkl', 'wb') as f:
    pickle.dump(model_fit, f)

# Forecasting
forecast_steps = 100
forecast_values = model_fit.forecast(steps=forecast_steps)

# Constructing forecast dates
forecast_dates = pd.date_range(start=data.index[-1], periods=forecast_steps + 1, freq='D')[1:]

# Plotting with Plotly
fig = go.Figure()

# Adding actual prices
fig.add_trace(go.Scatter(x=data.index, y=close_series, mode='lines', name='Actual Prices'))

# Adding forecasted values
fig.add_trace(go.Scatter(x=forecast_dates, y=forecast_values, mode='lines', name='Forecast'))

fig.update_layout(title='ARIMA Forecast for Stock Prices',
                  xaxis_title='Date',
                  yaxis_title='Price',
                  legend=dict(x=0, y=1, traceorder='normal'),
                  plot_bgcolor='rgba(0,0,0,0)')

fig.show()